# Tic-Tac-Toe

This game is a very simple version of tic-tac-toe which runs in the terminal, but the processes used to design and create it are the main focus.  The goal of this exercise was to practice solving problems using test-driven development (TDD) and an object-oriented design (OOD).


## Problem description:

* The game board is an empty 3x3 grid.
* There is one human player and one computer player.
* The human player selects an unoccupied position by selecting an integer from 1-9.
* The computer player selects a random unoccupied position.
* If any player selects an occupied position then they forfeit their turn.
* Each player's marker is placed on the board in their selected position.
* After each player's turn the board is checked for game over conditions.
* If any one player's markers fill a horizontal, vertical, diagonal or antidiagonal, then that player wins the game.
* If the board is full and no player has won then a tiebreak is declared
* After the game is over, the player is prompted to play again. The user can choose to play again or quit.


## Identify classes:

1. Extract nouns and verbs from the problem description as candidate classes/behaviour:
  * Game board
    * Has 3x3=9 positions
  * Human player
    * Is a human
    * Has a unique marker
    * Selects a position on the board
  * Computer player
    * Is a computer
    * Has a unique marker
    * Selects a random position on the board
  * Game board position
    * Is empty or has a marker placed on it
  * Player marker
    * Is either 'O' or 'X'
  * The game
    * Has two players
    * Has a board
    * Is over or is currently being played
    * Can determine when the game is over
    * Has a winner or is a tiebreak

2. Reduce the number of candidate classes: Similar classes might have a common parent class, or small classes might better be merged into a related class. Other classes might have all their properties covered by an existing data type like integer or list.
  * Board
    * Has 3x3=9 positions which are either empty or has a player's marker
    * Can determine if it has any free positions (is full)
    * Can determine if it contains three markers in a row:
      * Horizontal
      * Vertical
      * Diagonal
      * Antidiagonal
  * Player
    * Is either human or computer
    * Has a unique marker which is either 'X' or 'O'
    * Can select a position on the board, either manually, or at random
  * Game
    * Has 2 players: one computer, one human
    * Has a 3x3 game board
    * Can determine when the game is over (3 in a row or full board)
    * Can determine the winner of the game
    * Can display information about the game to the player

3. It's important not to rely on the language and phrasing of the problem statement too much when designing classes. You are trying to create useful data abstractions, not model the real world.

**Sources:**

* [A Real-world Introduction to Finding classes in Object-oriented Programming Languages](https://medium.com/xebia-engineering/a-real-world-introduction-to-finding-classes-in-object-oriented-programming-languages-612eae35b802)
* [How To Find Classes - Bertrand Meyer](https://archive.eiffel.com/doc/manuals/technology/oosc/finding/page.html)


## Design

Class: `Board`
Properties:
  - `positions`: The nine positions on the board.
Methods:
  - `place_marker(marker, position)`: Places `marker` in `position`, fails if - `position` has a `marker` already.
  - `winning_marker()`: Checks for a set of three markers in any orientation, and returns that marker, or None if there are no sets of three.
  - `is_full()`: Returns True if all 9 positions have markers, else False.

Class: `Player`
Properties:
  - `is_human`: True if the player is a human, else False.
  - `marker`: A marker to represent them, 'X' or 'O'.
Methods:
  - `select_position()`: Returns a position on the board. The is either input by the human player, or generated by the computer player.

Class: `Tictactoe`
Properties:
  - `player`: The human player
  - `computer`: The computer player
  - `board`: The game board.
Methods:
  - `display(message)`: Display `message` to the user.
  - `game_over()`: Returns True if `board.winning_marker()` is not None or `board.is_full()` returns True, else False.
  - `play()`: Gets each player's selection, updates the board, and handles any errors in the above. Loops until `game_over()` returns True.
